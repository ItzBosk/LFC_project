
# Documentation of the Shakespeare project

## Development philosophy
With this project we wanted to create a compiler for the Shakespeare programming language. The goal is to generate a script of what happens in the input file, also generating a PDF file divided into acts and scenes.

The underlying idea is to facilitate the first approach to programming for students who usually study literature or similar topics, which by their nature are quite distant from computer science. A use case could be using our software to teach students of a theater school. They are therefore familiar with elements such as the division of an opera into acts and scenes, and with the succession of actors' lines on stage. By taking advantage of this unique parallel that exists with the Shakespeare language, our product lends itself well to promoting the first contact between two areas that are usually considered poles apart.

## Used technologies
We decided to implement the Shakespeare language grammar via ANTLRv3 and manage the implementation part via Java. Using Eclipse as a development environment we were able to take advantage of the provided tools to generate the output PDF file starting from an ad-hoc stylized HTML. For the graphic part of the software we instead relied on Swing.

## File organization
### Main directory
There is the eclipse project folder "Workspace_Shakespeare", the file that summarizes the elements of the Shakespeare language "SPL.txt", described in more detail by the New Mexico Tech college in the file "Shakespeare programming language.pdf". Under "Documentation" you will find "Documentation.md" and the user manual "UserManual.md".

### Workspace_Shakespeare
- In "src" we can find:
	- "scanPackage" with the language Parser and Scanner files inside;
	- "grammarPackage" instead contains the files generated by ANTLR, including the grammar file called "Shakespeare.g", as well as the Error Handler;
	- "utilityPackage" includes support files such as "CharacterDescriptor.java" for managing objects relating to scene characters, "RomanNumber.java" for manipulating Roman numbers, and finally "Util.java" used to improve readability of the script printed in console;
	- "interfacePackage" includes all the files relating to the graphic part of the application;
	- "outputPackage" contains files related to the output pdf file
- In "resources" there are:
	- "images" with all the images of the characters and the rest of the graphic elements contained in the PDF that will be generated
	- "input.file", i.e. the text file to be compiled with the program written in Shakespeare language;
	- various useful icons for the graphical interface.
- "antlr-3.4-complete.jar", i.e. the ANTLRv3 library.

### Documentation
The documentation has been drawn up in English and Italian, respectively in "en" and it", so as to make understanding easier for every type of user.
- In "Documentazione.md" an overall view of the application created is given, specifying the reasons that led us to create it and the elements of the language that we considered.
- In "UserManual.md" we gave some useful advices that can help less experienced users take their first steps with the program.

## Main semantic checks
In this section we give an overview of the management of the semantic part of the Shakespeare language, making it clearer how and which rules we have implemented in the Parser.

### titleRule, bodyRule e dramatisPersonaeRule
Once the title of the Shakespeare program has been obligatorily recognized, we move on to the body of the script, identifying the declaration of the characters who will be able to enter the scene, requesting a comment for each of them. Each character must be declared only once and his name must be among those supported by the language.
We then expect the beginning of the opera, with a succession of multiple acts and scenes.

### actRule e sceneRule
With each change of act and scene, there is a Roman number that identifies its temporal position in the story, and a comment. It will then be checked that there are no time gaps, i.e. alterations to the natural numerical succession, otherwise reporting with an error message.

### enterRule, exitRule ed exeuntRule
At each entrance of one or more characters, the feasibility of the requested operation is verified. It is checked that a maximum of two characters are present on the scene at the same time, that undeclared and/or characters already present/left the scene cannot enter/exit.

### stageEventRule
In each stage event there is a character speaking to another character on stage, if present. A check is therefore carried out on his presence on stage, as well as an evaluation of which other character shares the stage with him.
All the main operations of the program take place within this semantic rule:
	- filling and emptying the stack associated with each character;
	- input and output of integer and ASCII values;
	- assignment of values.

### conditionalRule
Since it expresses a goto, it is necessary to verify that the scene to which the jump is requested exists within the current act. It is then essential to have kept track of the operations carried out during this scene, so as to be able to carry them out again, thus implementing cycles in the script.	

### rememberRule e recallRule
Through these two rules, the push and pop respectively take place in the stack of the character addressed by the speaker. It is therefore necessary to verify that the stack is not empty at the time of the request, in order to be able to make the character assume the value at the top of the respective stack.

### printRule e readRule
- In the first case we are printing the value of a character to the console. This can happen in two ways:
	- requesting the printing of the value associated with it, therefore it is necessary to verify that it has entered the scene at least once so that it can have been at least initialized to zero;
	- instead requesting the printing of the ASCII symbol corresponding to its value. In this case it is necessary to first check that this value is included in a pre-established range, so as to be able to print a valid symbol. This range goes from 32 to 126, allowing you to print on the screen the main existing symbols and all the letters included in all languages, uppercase and lowercase.
- With the second rule we read a user input, which can be numeric (integer) or an ASCII symbol:
	- in the case of reading a numerical value, it is verified that it is of the Integer type;
	- if instead you want to read a symbol, proceed with the control as in the case of the input.

### assignmentStatementRule, assignmentComparisonRule e assignmentOperationRule
These three rules assign character values. They reflect the three existing typologies in the Shakespeare language: direct assignment, by comparison or through the result of an equation. It is necessary to verify that the form required for each type is respected, checking that each assignment is legitimate, i.e. performed by a character declared and on stage, on another character with the same characteristics.

### adjectiveRule e adjectiveSecondRule
They facilitate the counting of the adjectives attributed to a character, in order to obtain the exact value of the power to be assigned to him.

